Cuando hablamos de programación de BBDD debemos mencionar **PL/SQL**, el lenguaje procedural diseñado para trabajar con **SQL**; además, está incluido con Oracle Database Server. A continuación detallaremos sus principales características:

- Integración con SQL
- Control de errores y excepciones
- Uso de variables
- Estructuras de control de flujo
- Soporte de programación orientada a objetos
- Programación modular: procedimientos y funciones

## 11.1. Entornos de desarrollo en el entorno de las BBDD

Tanto Oracle como MySQL tienen su propio intérprete, que son los siguientes:

- Oracle: Oracle SQL*Plus
- MySQL: MySQL Command Client

## 11.2. Sintaxis del lenguaje de programación

## 11.2.1. Bloques en PL/SQL

Los bloques son la forma más básica de programar en **PL/SQL**.  
Un bloque **se compila y se ejecuta en la base de datos**.  
Los **procedimientos y funciones se guardan como objetos**, mientras que el **bloque anónimo no se guarda**.

Todo bloque PL/SQL tiene tres partes:

- **Parte de declaraciones** (opcional): variables, constantes, cursores y excepciones definidas por el usuario.
- **Parte ejecutable** (obligatoria): sentencias de control y llamadas a funciones o procedimientos.
- **Parte de tratamiento de excepciones** (opcional): manejo de errores.

Ejemplo de cómo se realizan las tres partes:

![[Pasted image 20260121135137.png]]

Un bloque puede ser de tres tipos: función, procedimiento o anónimo; su objetivo es conseguir modularidad; para ello utilizamos procedimientos y funciones.

## Variables en PL/SQL

Las variables se declaran en la parte declarativa de un bloque PL/SQL.  
Sirven para almacenar datos y para pasar información a subprogramas (procedimientos y funciones).

### Modos de parámetros

- IN: dato de entrada (solo lectura).
- OUT: dato de salida.
- IN OUT: dato de entrada y salida.

### Constantes

Son variables cuyo valor no puede cambiar.

### Tipos de variables

- Compuestos: registros, arrays, tablas anidadas.
- LOB: datos grandes como texto, imágenes, audio o vídeo (hasta varios GB).
- Escalar

## Variables en MySQL

En MySQL existen palabras reservadas que no pueden usarse como nombres de variables. Si necesitamos usar una palabra reservada como identificador, debemos encerrarla entre comillas invertidas.  
Ejemplos: `SELECT` (si se usa como identificador, debe escaparse).  
También podemos usar variables de usuario, por ejemplo:  
`SET @minimo = 10000;`

Para usar ese dato en una consulta:  
`SELECT * FROM tabla WHERE cantidad < @minimo;`

## 11.2.3 Operadores

Estos son los operadores que se usan para relacionar y operar datos, por ejemplo:

- - y - : suma y resta
- / : división

Y así con todos los operadores aplicables en estructuras de control.

## 11.3 Procedimientos y funciones

Los procedimientos y las funciones son herramientas de PL/SQL y MySQL para reutilizar código.

Las funciones y los procedimientos tienen dos partes:

- Especificación: nombre del subprograma y tipos de argumentos; si es una función también se indica el valor que retorna.
- Cuerpo: aquí se escriben las sentencias por las que fue creado el procedimiento o la función.

## Procedimientos en PL/SQL

El procedimiento está creado por un conjunto de sentencias que serán ejecutadas cada vez que se invoquen.

Ejemplo: `CREATE [OR REPLACE] PROCEDURE [esquema.] nombre_procedure (nombre_parametro UT|INOUT} tipo_de_dato, …) S}

declaraciones_de_variables; declaraciones_de_constantes; declaraciones_de_cursores;

BEGIN

cuerpo_del_subprograma; [EXCEPTION bloque_de_excepciones;] END; / `

- **CREATE [OR REPLACE] PROCEDURE**: Crea el procedimiento y, si ya existe uno con el mismo nombre, lo reemplaza.
    
- **nombre_procedure**: Nombre que se asigna al procedimiento.
    
- **Parámetro formal**: Variable declarada en la cabecera del procedimiento (IN, OUT, INOUT) que actúa como variable local.
    
- **Parámetro actual**: Valor que se pasa al llamar al procedimiento y que se asigna al parámetro formal.
    

## 11.4. Control de errores

Una excepción es el resultado que se obtiene después de ejecutarse un bloque de PL/SQL que contiene un error.

La capturamos con EXCEPTION y la lanzamos con RAISE.

Tenemos algunas excepciones predefinidas que son:

- NO_DATA_FOUND: No devuelve ningún valor
- TOO_MANY_ROWS: La sentencia devuelve más de una fila
- INVALID_CURSOR: Se está haciendo referencia a un cursor no válido
- ZERO_DIVIDE: Se está tratando de dividir entre cero
- CASE_NOT_FOUND: El CASE no encontró una alternativa válida
- CURSOR_ALREADY_OPEN: Se está intentando abrir un cursor que ya está abierto
- INVALID_NUMBER: La cadena no puede convertirse a valor numérico porque no representa un número válido
- VALUE_ERROR: El valor falló en una operación aritmética
- LOGIN_DENIED: El programa está intentando ingresar con una contraseña incorrecta
- NOT_LOGGED_ON: El programa está intentando operar sin una conexión formalizada
- OTHERS: Otros errores que no se tomaron en cuenta

## 11.5. Cursores y transacciones

Los cursores son punteros que nos permiten iterar sobre el resultado de una consulta. De estos punteros tenemos dos tipos:

- Implícitos: Los utilizamos en las consultas SELECT INTO; este tipo de cursor solo devuelve una fila.
- Explícitos: Para consultas que retornan varios registros.

Los cursores implícitos solo pueden devolver una fila, por lo que si se solicita más de una se producirá una excepción como NO_DATA_FOUND o TOO_MANY_ROWS.

- OPEN: Para utilizar el cursor debemos abrirlo.
- FETCH: Con esto extraemos datos de un registro y lo guardamos en una variable.
- CLOSE: Se cierra el cursor.

Como no sabemos qué hacen los cursores directamente, lo que hacemos es verificar cómo les fue con estos atributos:

- **`SQL%FOUND`** → `TRUE` si la sentencia afectó al menos una fila
- **`SQL%NOTFOUND`** → `TRUE` si no afectó ninguna fila
- **`SQL%ROWCOUNT`** → número de filas afectadas
- **`SQL%ISOPEN`** → siempre `FALSE` (Oracle los abre y cierra solo)

## 11.6. Disparadores o triggers

Va a ser útil cuando queramos:

- **Forzar reglas de integridad**: Que son difíciles de definir con constraints.
- **Realizar cambios en la BD** de forma transparente para el usuario.
- **Sincronizar el mantenimiento de tablas duplicadas** que están ubicadas en distintos nodos.
- **Generar automáticamente valores de columnas derivadas**.

Los triggers nos ayudarán a imponer restricciones de integridad más específicas, como:

- **Not null**: No admite valores nulos.
- **Unique**: Solo valores únicos.
- **Primary key**: Clave primaria.
- **Check**: Reglas más complejas.
- **Foreign key**: Restricciones de integridad referencial.

Después de ver qué restricciones podemos aplicar, debemos tener en cuenta en qué momento queremos que se ejecute el trigger:

- **BEFORE**: Lo usaremos cuando queramos revisar los cambios antes de que se hagan efectivos sobre la tabla, para poder modificarlos si hay algún problema.
- **AFTER**: Esto lo utilizaremos después de los cambios.
- **FOR EACH ROW**: Se ejecutará por cada fila.
- **WHEN**: Podemos incluir condiciones.

También podemos utilizar los triggers según el tipo de operación que los dispare:

- **INSERTING**: Devuelve true si el trigger ha sido disparado por un INSERT.
- **DELETING**: Devuelve true si el trigger ha sido disparado por un DELETE.
- **UPDATING**: Devuelve true si el trigger ha sido disparado por un UPDATE.

Para hacer referencia al código nuevo o al código viejo tenemos dos palabras clave:

- **OLD**: Se refiere al valor antiguo, antes de ser modificado.
- **NEW**: Se refiere al valor nuevo, después de ser modificado.